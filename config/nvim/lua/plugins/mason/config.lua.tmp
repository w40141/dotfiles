local M = {}

function M.mason_tool_installer()
	local v = vim
	require("mason-tool-installer").setup({
		ensure_installed = {
			"actionlint",
			"bash-language-server",
			"black",
			"codespell",
			"cspell",
			"deno",
			"docker-compose-language-service",
			"dockerfile-language-server",
			"eslint-lsp",
			"eslint_d",
			"fixjson",
			"gofumpt",
			"golangci-lint",
			"gopls",
			"graphql-language-service-cli",
			"hadolint",
			"html-lsp",
			"jdtls",
			"kotlin-language-server",
			"latexindent",
			"lua-language-server",
			"markdownlint",
			"marksman",
			"prettier",
			"prisma-language-server",
			"pyright",
			"ruff",
			"ruff-lsp",
			"rust-analyzer",
			"selene",
			"shellcheck",
			"shfmt",
			"sql-formatter",
			"sqlfluff",
			"sqlls",
			"stylua",
			"texlab",
			"typescript-language-server",
			"typos",
			"vulture",
			"yamlls",
			"yamlfmt",
			"yamllint",
		},
		auto_update = true,
		run_on_start = true,
		start_delay = 3000,
	})

	local m = v.api.nvim_create_augroup("Mason", {})
	v.api.nvim_create_autocmd("User", {
		pattern = "MasonToolsUpdateCompleted",
		callback = function()
			v.schedule(function()
				print("mason-tool-installer has finished")
			end)
		end,
		group = m,
	})
end

function M.mason()
	require("mason").setup({
		ui = {
			icons = {
				package_installed = "✓",
				package_pending = "➜",
				package_uninstalled = "✗",
			},
		},
	})
end

function M.conform()
	local v = vim
	local conform = require("conform")

	-- local prettier_ft = {
	--   "angular",
	--   "css",
	--   "flow",
	--   "graphql",
	--   "html",
	--   "json",
	--   "jsx",
	--   "javaScript",
	--   "less",
	--   "markdown",
	--   "scss",
	--   "typescript",
	--   "vue",
	--   "yaml",
	-- }
	--
	-- for _, filetype in pairs(prettier_ft) do
	--   formatters[filetype] = { "prettier" }
	-- end
	-- ✓ latexindent (keywords: latex)
	--   ✓ black
	-- ✓ fixjson
	-- ✓ gofumpt
	-- ✓ latexindent
	-- ✓ prettier
	-- ✓ shfmt
	-- ✓ sql-formatter
	-- ✓ stylua
	-- ✓ yamlfmt

	conform.setup({
		formatters_by_ft = {
			bash = { "shfmt" },
			elixir = { "mix" },
			fish = { "fish_indent" },
			go = { "gofumpt", "gofmt", "goimports", "golines" },
			javascript = { "prettier" },
			json = { "fixjson" },
			lua = { "stylua" },
			markdown = { "markdownlint" },
			python = { "black" },
			rust = { "rustfmt" },
			sh = { "shfmt" },
			sql = { "sql-formatter" },
			yaml = { "yamlfmt" },
			-- Use the "*" filetype to run formatters on all filetypes.
			["*"] = { "codespell" },
			-- Use the "_" filetype to run formatters on filetypes that don't
			-- have other formatters configured.
			["_"] = { "trim_whitespace", "trim_newlines", "squeeze_blanks" },
		},
		-- If this is set, Conform will run the formatter on save.
		-- It will pass the table to conform.format().
		-- This can also be a function that returns the table.
		format_on_save = {
			-- I recommend these options. See :help conform.format for details.
			lsp_fallback = true,
			timeout_ms = 500,
		},
		-- If this is set, Conform will run the formatter asynchronously after save.
		-- It will pass the table to conform.format().
		-- This can also be a function that returns the table.
		format_after_save = {
			lsp_fallback = true,
		},
		-- Set the log level. Use `:ConformInfo` to see the location of the log file.
		log_level = v.log.levels.ERROR,
		-- Conform will notify you when a formatter errors
		notify_on_error = true,
		-- Custom formatters and changes to built-in formatters
	})

	-- local custom_formatters = {
	--   csharpier = {
	--     command = "dotnet-csharpier",
	--     args = "--write-stdout",
	--     stdin = true,
	--   },
	-- }
	--
	-- local formatters = {
	--   lua = { "stylua" },
	--   python = { "autopep8" },
	--   cpp = { "clang_format" },
	--   c = { "clang_format" },
	--   go = { "gofumpt" },
	--   cs = { "csharpier" },
	-- }
	--
	--
	-- return {
	--   formatters = custom_formatters,
	--   format_on_save = {
	--     -- These options will be passed to conform.format()
	--     async = true,
	--     quiet = true,
	--     lsp_fallback = true,
	--   },
	--   formatters_by_ft = formatters,
	-- }
end

function M.nvim_lint()
	local v = vim
	local api = v.api
	local lint = require("lint")

	local linters = {
		bash = { "shellcheck" },
		docker = { "hadolint" },
		go = { "golangcilint" },
		javascript = { "eslint_d" },
		lua = { "selene" },
		python = { "ruff", "vulture" },
		sh = { "shellcheck" },
		sql = { "sqlfluff" },
		typescript = { "eslint_d" },
		yaml = { "yamllint", "actionlint" },
		zsh = { "shellcheck" },
	}

	local mason_linters = {
		"actionlint",
		"eslint_d",
		"hadolint",
		"ruff",
		"selene",
		"shellcheck",
		"sqlfluff",
		"vulture",
		"yamllint",
		"golangci-lint",
	}

	require("mason-nvim-lint").setup({
		ensure_installed = mason_linters,
	})

	-- ✓ codespell (keywords: )
	-- ✓ textlint (keywords: text, markdown)
	-- ✓ typos (keywords: )
	lint.linters_by_ft = linters

	api.nvim_create_autocmd({ "BufWritePost" }, {
		callback = function()
			lint.try_lint()
		end,
	})
end

return M
